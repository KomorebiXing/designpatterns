package com.sjms.wq.行为型.模板方法模式.demoone;

import com.sjms.wq.行为型.模板方法模式.demoone.bo.CaffeineBeverage;
import com.sjms.wq.行为型.模板方法模式.demoone.bo.Coffee;
import com.sjms.wq.行为型.模板方法模式.demoone.bo.Tea;

/**
 * @Author: 世墨
 * @Date: 2022/4/12 9:16
 * @DESCRIPTION 模板方法模式
 *
 */
public class Test {

    @org.junit.jupiter.api.Test
    void test_coffee_tea(){
        final Coffee coffee = new Coffee();
        coffee.prepareRecipe();

        final Tea tea = new Tea();
        tea.prepareRecipe();
        /**
         * 咖啡和茶的冲泡方法
         * 有两个方法是大致相同的
         *  这就导致了重复代码的出现
         */
    }

    /**
     * 进行改进咖啡和茶的冲泡方法 ，提供抽象类
     * 进行抽取公共的方法
     * 和提供抽象的方法 ——————> 该方法是大致类型的动作 比如咖啡要加入咖啡因子 ，茶要加灵梦，抽象一点想其实就是 加入配料而已
     */

    @org.junit.jupiter.api.Test
    void test_coffee_tea_abstract(){
        CaffeineBeverage caffeineBeverage1 = new Tea();
        CaffeineBeverage caffeineBeverage2 = new Coffee();

        caffeineBeverage1.prepareRecipe();
        caffeineBeverage2.prepareRecipe();
    }

    /**
     * 上面的例子就是一个简单的模板方法
     * 也是prepareRecipe()这个方法是一个模板方法
     * 为什么？
     * 1.毕竟他是一个方法
     * 2.它作一个算法的模板，在这个例子中 ，算法是用来制作咖啡因饮料的，在这个模板中，算法内的每个步骤都被一个方法代表，某些方法是由这个类去做处理的
     * 某些方法是由子类去做处理的，而需要子类处理的方法，被声明为抽象
     *
     * 那什么是模板方法呢：
     * 其实就是定义了一个算法的步骤，并允许子类为一个后多个步骤提供实现，简单来说就是在一个方法中定义一个算法的骨架(框架)，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，
     * 重新定义算法中的某些步骤(方法)
     * 也可以理解为一个模板类，里面的每个模板方法都是一个具体的算法，而实现这些具体的算法是由子类的方法去做的，如果遇到相同的逻辑可以提取出来，以减小代码的可重复性
     *
     * 这么说把，还是从上面的例子来看，因为星巴滋 他家的冲泡方法 无论是茶还是咖啡都有自己的冲泡方法，这个时候我们只需要定义号模板，
     * 如果是茶 那就调用茶的模板方法 如果是咖啡那就调用咖啡的模板方法，当时他们是继承一个模板方法，只不过对其抽象方法做了自己想要的实现
     *
     * 模板方法类专注在算法本身，具体实现是由子类完成的
     */

    /**
     * 进阶用法：挂钩用法
     * 其实狠简单 就是利用一个方法来控制，是否要执行某个算法
     * 这个方法是在超类里面定义的先是默认的方法
     * 子类可以对他进行实现，修改默认的逻辑，从而让模板方法里面的部分算法是否进行执行
     */

    /**
     * 好莱坞原则：别调用我们，我们会去调用你
     * 怎么说呢？
     * 模板方法就是这样的
     * 我模板方法类和子类，不需要你子类去调用我，我需要什么我回去子类调用你的方法，来组成具体某一个算法(需求)
     *
     * 好莱坞原则：主要是为了防止”依赖腐败“的方法，当 高层组件 依赖  底层组件 ，而 底层组件 又依赖于 高层组件 ，高层组件 又依赖 侧边组件 ，侧边组件 又依赖于 底层 组件 ，这样就会导致
     * 依赖腐败的发送，在这种情况下，没有人可以轻易的搞明系统是如设计的。
     *
     * 在好莱坞原则下 ，高层组件 允许 底层组件 挂钩 高层，但是绝对不许 底层 调用 高层 ，换句话说就是 ：  别调用我们，我们会去调用你
     */
}
